use super::{Env, EnvTable, Error, Expr, Symbol};

/// Type representing an anonymous 
/// procedure created using the
/// [`Lambda`](super::Builtin::Lambda) builtin.
/// 
/// A [`Procedure`] always captures the [`Env`] 
/// that it's been created in (see [`EnvTable`]).
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Procedure {
    params: Vec<Symbol>,
    body: Box<Expr>,
    capture_env: Env,
}

impl Procedure {
    /// Create a new [`Procedure`] capturing
    /// `parent_env` using a dummy [`Env`].
    pub fn new(
        params: Vec<Symbol>,
        body: Box<Expr>,
        parent_env: Env,
        env_table: &mut EnvTable,
    ) -> Self {
        Self {
            params,
            body,
            capture_env: env_table.env_create(parent_env),
        }
    }

    /// Evaluate the [`Procedure`] with the
    /// passed `args`. This method can be called as a result of of evaluating the
    /// [`Call`](Expr::Call) expression.
    /// 
    /// A new [`Env`] containing every
    /// parameter's new definition is always created and passed
    /// as `env` when evaluating the body of the [`Procedure`].
    /// When succesfully evaluated, the method tries to delete
    /// unneeded [`Env`]s from the [`EnvTable`] (see [`EnvTable::env_try_destroy`]).
    /// 
    /// # Errors
    /// [`Error::IncorrectArgCount`] is returned if `self.params.len() != args.len()`.
    /// 
    /// This method also recursively returns any error generated by [`Expr::eval`].
    pub fn eval(
        self,
        env_table: &mut EnvTable,
        parent_env: Env,
        args: Vec<Expr>,
    ) -> Result<Expr, Error> {
        if self.params.len() != args.len() {
            return Err(Error::IncorrectArgCount {
                expected: self.params.len(),
                found: args.len(),
                expr: Expr::Procedure(self),
            });
        }

        let env = env_table.env_create(self.capture_env);

        for (param, arg) in self.params.iter().zip(args) {
            let arg_eval = arg.eval(env_table, parent_env)?;
            env_table.symbol_define(*param, env, arg_eval);
        }

        let res = self.body.eval(env_table, env);

        env_table.env_try_destroy(env);

        res
    }

    /// Return the dummy [`Env`] used
    /// to capture the environment
    /// the [`Procedure`]'s been created in.
    pub fn captured_env(&self) -> Env {
        self.capture_env
    }

    /// Return a slice of the [`Procedure`]'s
    /// parameters.
    pub fn params(&self) -> &[Symbol] {
        &self.params
    }

    /// Return the [`Procedure`]'s body.
    pub fn body(&self) -> &Expr {
        &self.body
    }
}
